package southday.java.acm.nowcoder.bytedance.spring2019;

/*
题目：字节跳动2019春招研发部分编程题汇总，2/7
https://www.nowcoder.com/test/16516564/summary

我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议

1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。
2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！
……
万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！

请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。
注意：
1. 两个特工不能埋伏在同一地点
2. 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用输入描述:
第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)
第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）输出描述:
一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

输入描述:
第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)
第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）

输出描述:
一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

输入例子1:
4 3
1 2 3 4

输出例子1:
4

例子说明1:
可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)

输入例子2:
5 19
1 10 20 30 50

输出例子2:
1

例子说明2:
可选方案 (1, 10, 20)
 */

import java.util.Scanner;

/**
 * 万万没想到之抓捕孔连顺
 * @author southday
 * @date 2020/2/19
 */
public class ArrestMrKong {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int D = sc.nextInt();
        long[] nodes = new long[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = sc.nextLong();
        }
        long count = 0L;
        long n = 0L;
        for (int i = 0, j = i + 2; i < N - 2; i++) {
            while (j < N && nodes[j] - nodes[i] <= D) {
                j++;
            }
            n = (j - 1L) - (i + 1L) + 1L;
            // 排列组合 Cn,2 = n * (n - 1) / 2;
            count += (n * (n - 1L) / 2L);
        }
        System.out.println(count % 99997867L);
    }
}

/*
解题思路：
1）从左到右，固定 nodes[i]，然后从剩余的部分中任取2个数，根据排列组合公式Cn,2 = n * (n - 1) / 2，可以求出包含 nodes[i] 的所有组合；
2）在求完包含 nodes[i] 的所有组合后，i++，即：下一次求的组合中不包含已经求过的 nodes[i]，这样就能避免重复；
3）“剩余部分”的取值，则是根据角标 j，初始化为 i + 2，即：要保证有3个元素；直到找到第一个 nodes[j] - nodes[i] > D 的元素时停止循环，此时“剩余部分”的个数为：(j - 1) - (i + 1) + 1；
4）有一点需要注意，角标 j 在第一次初始化为 i + 2后，后面的取值都是与上一次循环有关，因为如果：nodes[j] - nodes[i-1] <= D，那么 nodes[j] - nodes[i] 也一定 <= D（数列递增），所以为了提高效率，省略了上一次循环中已经扫描过的角标 j；
 */
